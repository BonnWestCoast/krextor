Krextor is the KWARC RDF Extractor.  It is an extensible XSLT-based framework
for extracting RDF from XML, supporting multiple input languages as well as
multiple output RDF notations.  Krextor provides convenience templates that try
to do “the right thing”™ in many common cases, as to reduce the need for
manually writing repetitive code.

The extracted RDF graph will in most cases be an outline of the semantic
structure of an XML document, abstracting from the concrete syntax.  It can be
used for more easily exchanging or interlinking knowledge contained in XML
documents on the semantic web.  There are many tools that support querying RDF,
using languages like SPARQL.  If the extracted RDF is backed by an expressive
ontology, a reasoner can be used to infer additional knowledge from it.

== Contact ==

Homepage: http://kwarc.info/projects/krextor/
Wiki: http://mathweb.org/wiki/Krextor
Bug reports: https://trac.kwarc.info/krextor/
Mailing list: http://lists.jacobs-university.de/mailman/listinfo/project-swim (for now)

== Releases ==

* trunk: most recent development version
* tags: older versions
  * 0.1
  * 0.2

See ChangeLog for details.

== Requirements ==

An XSLT 2.0 compliant XSLT processor.  Krextor has been tested with the
following XSLT processors:

* Saxon 9.1 (see http://www.saxonica.com)
* Gestalt 1.0 (see http://gestalt.sourceforge.net/)

We appreciate reports from users of other XSLT processors.

== Usage ==

In order to extract RDF from XML, you need to know the name of the extraction
module for the desired XML language (e.g. OMDoc) and the name of the output
module for the desired output RDF notation (e.g. RXR).

Popular transformations (e.g. OMDoc to RXR) are available as pre-defined
stylesheets, e.g.  transform-omdoc-rxr.xsl.

Run it with
$ saxon document.omdoc transform-omdoc-rxr.xsl

For other conversions, or if you want to override the extraction in an
application-specific way, you have to compose your own stylesheet that imports
the desired extraction and output modules.  Let's assume that we want to
extract RXR from OpenMath Content Dictionaries (ocd) and that the Krextor XSLTs
are located in the subdirectory “krextor”:

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0">
  <xsl:import href="krextor/output-rdf-rxr.xsl"/>
  <xsl:import href="krextor/extract-ocd-rdf.xsl"/>

  <!-- Put application-specific template here.  You can also override 
       imported templates. -->
</xsl:stylesheet>

== Extending ==

Please let us know if you have written any extraction or output module, test
case, or documentation that you would like us to make a part of the Krextor
default distribution.

=== Extraction ===

To write an extraction module for a new XML language, copy one of the existing
ones.  Then read and understand the documentation of generic-templates.xsl,
particularly the named templates in the krextor namespace:

* create-resource
  Creates an RDF resource of some type from this element, and probably creates
  related triples having this resource as a subject or object.  Resources can
  be identified by auto-generated URIs, by custom URIs, or by blank node IDs.
  Then, matching extraction templates are applied to the child elements.  A
  call to create-resource defines a scope in which the created resource is the
  default subject of any other triple created using these templates, unless
  another resource is created from some child element.
* add-literal-property
  Adds a literal-valued property to the resource in whose create-resource scope
  this template was called.
* add-uri-property
  Adds a URI-valued property to the resource R in whose create-resource scope
  this template was called.  R can either be subject (default) or object
  (“inverse mode”) of the resulting triple.

These templates make typical RDF extraction tasks much easier than directly
creating output triples using the output-triple function in the output module.
See the source code for additional documentation.

As a rule of thumb, we recommend that every XML element or attribute that
corresponds to one RDF resource or property be matched by one template that
calls one of the templates above.  This ensures the most effective default
behaviour without requiring you to write much code yourself.  More particularly:

1. If an element E corresponds to a resource, write a template that matches E
   and calls create-resource.
2. If an element E contains text that corresponds to the value of a property of
   a resource represented by a parent or ancestor element, write a template
   that matches E and calls add-literal-property or add-uri-property.
3. If an attribute A contains text that corresponds to the value of a property
   of a resource represented by its parent element E, write a template that
   matches A and calls add-literal-property or add-uri-property.
   create-resource, as called from a template matching E, ensures that
   templates are applied to attributes, too – which is not generally the case
   in XSLT.
4. If an element E corresponds to a resource that is related to a resource
   represented by a parent or ancestor element P via a property P–prop–E (e.g.
   a part-of relationship), match E as in case (1), but pass the parameter
   related-via-properties with value ‘prop’.  This is designed as a
   (comma-separated) sequence because sometimes there can be more than one such
   property, e.g. one logical relation and one document structure relation.

A template that traverses XInclude links is provided in generic-templates.xsl
and active by default.  Templates are applied to nodes in XIncluded documents
in “included” mode.  A rule of thumb is not to recursively create resources
from XIncluded elements, but to process these documents separately and then
merge the resulting RDF graphs.  It is recommended to just generate part-of
relationships from the including document to the resource represented by the
root element of the included document, this time using add-uri-property and its
default behaviour.

==== Example ====

Consider the following XML format for data about social networks:

<person friends="http://van-houten.name/milhouse">
  <name>Bart Simpson</name>
</person>

Here is a Krextor XSLT snippet that extracts RDF using the FOAF ontology
(http://www.foaf-project.org), assuming namespaces prefixes and XML entities
are set up correctly:

<xsl:template match="person">
  <xsl:call-template name="krextor:create-resource">
    <xsl:with-param name="type" select="'&foaf;Person'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template match="person/@friends">
  <xsl:call-template name="krextor:add-uri-property">
    <xsl:with-param name="property" select="'&foaf;knows'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template match="person/name">
  <xsl:call-template name="krextor:add-literal-property">
    <xsl:with-param name="property" select="'&foaf;name'"/>
  </xsl:call-template>
</xsl:template>

=== Output ===

To write an extraction module for a new RDF notation, copy and adapt the
following template:

<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:krextor="http://kwarc.info/projects/krextor/"
    exclude-result-prefixes="krextor"
    version="2.0">
    <!-- Note that text output is possible, too. -->
    <xsl:output method="xml" encoding="UTF-8" indent="yes" omit-xml-declaration="no"/>

    <xsl:import href="generic-templates.xsl"/>

    <!-- creates one RDF triple -->
    <xsl:template name="krextor:output-triple">
	<!-- value of the subject -->
	<xsl:param name="subject" required="yes"/>
	<!-- type of the subject: either 'uri' or 'blank' -->
	<xsl:param name="subject-type" select="'uri'"/>

	<!-- value of the predicate -->
	<xsl:param name="predicate" required="yes"/>

	<!-- value of the object -->
	<xsl:param name="object" required="yes"/>
	<!-- type of the object: either 'uri' or 'blank',
	     or nothing for literal objects -->
	<xsl:param name="object-type"/>
	<!-- language annotation is only supported on the object,
	     but neither on triples nor on graphs, as in RXR -->
	<xsl:param name="object-language"/>
	<!-- datatype of the (literal) object -->
	<xsl:param name="object-datatype"/>

        <!-- output the triple -->
    </xsl:template>

    <xsl:template match="/">
	<!-- begin output -->
	<xsl:apply-imports/>
	<!-- end output -->
    </xsl:template>
</xsl:stylesheet>

Blank nodes, as well as language and datatype annotations for objects, will
only be generated if the extraction module requests it; that is, for simple
applications you can ignore these parameters.  For other applications, such as
a simple graph visualisation, you may not even want to distinguish between e.g.
URIs and blank nodes.

Note that the current design of Krextor is optimised for sequential triples
generation, i.e.

< subject1, predicate1, object1 >
< subject2, predicate2, object2 >
...

Grouping triples by a common subject, as commonly done in RDF/XML, N3 or
Turtle, is not easy to achieve.  However, this is only syntactic sugar making
these notations easier to read for humans.  Krextor's output is intended for
machine-processing instead.

== Authors ==

* Christoph Lange <ch.lange@jacobs-university.de>
  General architecture
  OMDoc extractor (partly)
  OpenMath extractor
  RXR output
* Gordan Ristovski <g.ristovski@jacobs-university.de>
  OMDoc extractor (partly)
* Andrei Ioniţă <a.ionita@jacobs-university.de>
  OMDoc extractor (MMT a.k.a. OMDoc 1.3 URIs)

