Krextor is the KWARC RDF Extractor.  It is an extensible XSLT-based framework
for extracting RDF from XML, supporting multiple input languages as well as
multiple output RDF notations.  Krextor provides convenience templates that try
to do “the right thing”™ in many common cases, as to reduce the need for
manually writing repetitive code.

== Contact ==

Homepage: http://kwarc.info/projects/krextor/
Wiki: http://mathweb.org/wiki/Krextor
Bug reports: https://trac.kwarc.info/krextor/
Mailing list: http://lists.jacobs-university.de/mailman/listinfo/project-swim (for now)

== Releases ==

* trunk: most recent development version
* tags: older versions
  * 0.1

See ChangeLog for details.

== Requirements ==

An XSLT 2.0 compliant XSLT processor.  Krextor has been tested with Saxon 9.0.

== Usage ==

In order to extract RDF from XML, you need to know the name of the extraction
module for the desired XML language (e.g. OMDoc) and the name of the output
module for the desired output RDF notation (e.g. RXR).

Popular transformations (e.g. OMDoc to RXR) are available as pre-defined
stylesheets, e.g.  transform-omdoc-rxr.xsl.

Run it with
$ saxon document.omdoc transform-omdoc-rxr.xsl

For other conversions, or if you want to override the extraction in an
application-specific way, you have to compose your own stylesheet that imports
the desired extraction and output modules.  Let's assume that we want to
extract RXR from OpenMath Content Dictionaries (ocd) and that the Krextor XSLTs
are located in the subdirectory "krextor":

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0">
  <xsl:import href="krextor/output-rdf-rxr.xsl"/>
  <xsl:import href="krextor/extract-ocd-rdf.xsl"/>

  <!-- Put application-specific template here.  You can also override 
       imported templates. -->
</xsl:stylesheet>

== Extending ==

Please let us know if you have written any extraction or output module, test
case, or documentation that you would like us to make a part of the Krextor
default distribution.

=== Extraction ===

To write an extraction module for a new XML language, copy one of the existing
ones.  Then read and understand the documentation of generic-templates.xsl,
particularly the named templates:

* create-resource
  Creates an RDF resource of some type from this element, and probably creates
  related triples having this resource as a subject or object.  Then, matching
  extraction templates are applied to the child elements.  A call to
  create-resource defines a scope in which the created resource is the default
  subject of any other triple created using these templates, unless another
  resource is created from some child element.
* add-literal-property
  Adds a literal-valued property to the resource in whose create-resource scope
  this template was called.
* add-uri-property
  Adds a URI-valued property to the resource in whose create-resource scope
  this template was called.

These templates make typical RDF extraction tasks much easier than directly
creating output triples using the functions in the output modules.  See the
source code for additional documentation.

As a rule of thumb, we recommend that every XML element or attribute that
corresponds to one RDF resource or property be matched by one template that
calls one of the templates above.  This ensures the most effective default
behaviour without requiring you to write much code yourself.  More particularly:

1. If an element E corresponds to a resource, write a template that matches E
   and calls create-resource.
2. If an element E contains text that corresponds to the value of a property of
   a resource represented by a parent or ancestor element, write a template
   that matches E and calls add-literal-property or add-uri-property.
3. If an attribute A contains text that corresponds to the value of a property
   of a resource represented by its parent element E, write a template that
   matches A and calls add-literal-property or add-uri-property.
   create-resource, as called from a template matching E, ensures that
   templates are applied to attributes, too – which is not generally the case
   in XSLT.
4. If an element E corresponds to a resource that is related to a resource
   represented by a parent or ancestor element P via a property P–prop–E (e.g.
   a part-of relationship), match E as in case (1), but pass the parameter
   related-via-property with value ‘prop’.

A template that traverses XInclude links is provided in generic-templates.xsl
and active by default.  Templates are applied to nodes in XIncluded documents
in "included" mode.  A rule of thumb is not to recursively create resources
from XIncluded elements, but to process these documents separately and then
merge the resulting RDF graphs.  It is recommended to just generate part-of
relationships from the including document to the resource represented by the
root element of the included document, this time using add-uri-property and its
default behaviour.

=== Output ===

To write an extraction module for a new RDF notation, copy and adapt the
following template:

<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:krextor="http://kwarc.info/projects/krextor/"
    exclude-result-prefixes="krextor"
    version="2.0">
    <xsl:output method="xml" encoding="UTF-8" indent="yes" omit-xml-declaration="no"/>

    <xsl:include href="generic-templates.xsl"/>

    <xsl:function name="krextor:triple-uri">
	<xsl:param name="subject"/>
	<xsl:param name="predicate"/>
	<xsl:param name="object"/>
	<!-- Output a triple with a URI object, possible by calling
	     krextor:triple -->
    </xsl:function>
    
    <xsl:function name="krextor:triple-lit">
	<xsl:param name="subject"/>
	<xsl:param name="predicate"/>
	<xsl:param name="object"/>
	<!-- Output a triple with a literal object, possible by calling
	     krextor:triple -->
    </xsl:function>

    <!-- This function is not strictly needed, but helpful to avoid
         redundancies in the functions above. -->
    <xsl:function name="krextor:triple">
	<xsl:param name="subject"/>
	<xsl:param name="predicate"/>
	<xsl:param name="object"/>
        <!-- Output a generic triple -->
    </xsl:function>

    <xsl:template match="/">
	<!-- begin output -->
	<xsl:apply-imports/>
	<!-- end output -->
    </xsl:template>
</xsl:stylesheet>

Note that the current design of Krextor is optimised for sequential triples
generation, i.e.

< subject1, predicate1, object1 >
< subject2, predicate2, object2 >
...

Grouping triples by a common subject, as commonly done in RDF/XML, N3 or
Turtle, is not easy to achieve.  However, this is only syntactic sugar making
these notations easier to read for humans.  Krextor's output is intended for
machine-processing instead.

== Authors ==

* Christoph Lange <ch.lange@jacobs-university.de>
  General architecture
  OMDoc extractor (partly)
  OpenMath extractor
  RXR output
* Gordan Ristovski <g.ristovski@jacobs-university.de>
  OMDoc extractor (partly)
* Andrei Ioniţă <a.ionita@jacobs-university.de>
  OMDoc extractor (MMT a.k.a. OMDoc 1.3 URIs)

